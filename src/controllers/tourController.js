// controllers/tourController.js
const Tour = require("../models/Tour");
const Category = require("../models/Category");
const Location = require("../models/Location");
const Hotel = require("../models/Hotel");
const Destination = require("../models/Destination");
const Departure = require("../models/Departure");
const TourDay = require("../models/TourDay");
const TourDayDestination = require("../models/TourDayDestination");
const TourDestination = require("../models/TourDestination");
const { sequelize } = require("../models");
const { Op } = require("sequelize");
const cloudinary = require("../config/cloudinary");
const fs = require("fs");
const path = require("path");

const TOUR_INCLUDE = [
  { model: Category, as: "fixedCategory" },
  { model: Category, as: "optionalCategories", through: { attributes: [] } },
  { model: Location },
  { model: Hotel },
  { model: Departure },
  {
    model: TourDay,
    as: "tourDays",
    include: [
      {
        model: TourDayDestination,
        include: [{ model: Destination }]
      }
    ]
  }
];


// L·∫•y t·∫•t c·∫£ tour
exports.getAllTours = async (req, res) => {
  try {
    const tours = await Tour.findAll({ include: TOUR_INCLUDE });

    res.json({
      success: true,
      data: tours.map(tour => ({
        ...tour.toJSON(),
        statusComputed: tour.tourStatus, // d√πng virtual
        salePrice: tour.salePrice        // lu√¥n tr·∫£ salePrice
      }))
    });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
};

// L·∫•y tour theo id
exports.getTourBySlug = async (req, res) => {
  try {
    const tour = await Tour.findOne({
      where: { slug: req.params.slug },
      include: [
        { model: Category, as: "fixedCategory" },
        { model: Category, as: "optionalCategories", through: { attributes: [] } },
        { model: Location },
        { model: Hotel },
        {
          model: TourDay,
          as: "tourDays",  // ph·∫£i tr√πng v·ªõi alias Tour.hasMany(TourDay, {as: "tourDays"})
          include: [
            {
              model: TourDayDestination,
              include: [
                {
                  model: Destination
                }
              ]
            }
          ]
        }
      ]
    });

    if (!tour) return res.status(404).json({ error: "Kh√¥ng c√≥ tour" });

    const tourData = tour.toJSON();
    tourData.tourDays = tourData.tourDays.map(day => ({
      ...day,
      destinationIds: day.TourDayDestinations.map(td => td.Destination.id)
    }));

    res.json({
      success: true,
      data: {
        ...tourData,
        statusComputed: tour.tourStatus,
        salePrice: tour.salePrice
      }
    });

  } catch (err) {
    res.status(500).json({ error: err.message });
  }
};

// T·∫°o tour m·ªõi
exports.createTour = async (req, res) => {
  const t = await sequelize.transaction();
  try {
    const {
      name,
      description,
      price,
      startDate,
      endDate,
      capacity,
      status,
      fixedCategoryId,
      location_id,
      hotel_id,
      discount = 0,
      isHotDeal = false,
      departureId,
    } = req.body;

    // --- Parse JSON t·ª´ frontend (tr√°nh tr∆∞·ªùng h·ª£p b·ªã stringify) ---
    let optionalCategoryIds = [];
    let destinationIds = [];
    let daysData = [];

    if (req.body.optionalCategoryIds) {
      try {
        optionalCategoryIds = JSON.parse(req.body.optionalCategoryIds);
      } catch {
        optionalCategoryIds = Array.isArray(req.body.optionalCategoryIds)
          ? req.body.optionalCategoryIds
          : [];
      }
    }

    if (req.body.destinationIds) {
      try {
        destinationIds = JSON.parse(req.body.destinationIds);
      } catch {
        destinationIds = Array.isArray(req.body.destinationIds)
          ? req.body.destinationIds
          : [];
      }
    }

    if (req.body.days) {
      try {
        daysData = JSON.parse(req.body.days);
      } catch {
        return res.status(400).json({ error: "Days format invalid" });
      }
    }

    // --- Ki·ªÉm tra danh m·ª•c c·ªë ƒë·ªãnh ---
    const fixedCategory = await Category.findOne({
      where: { id: fixedCategoryId, type: "fixed" },
    });
    if (!fixedCategory)
      return res.status(400).json({ error: "Danh m·ª•c c·ªë ƒë·ªãnh kh√¥ng h·ª£p l·ªá" });

    // --- Ki·ªÉm tra location ---
    let validLocationId = null;
    if (location_id) {
      const location = await Location.findOne({
        where: { id: location_id, fixedCategoryId },
      });
      if (!location)
        return res.status(400).json({ error: "Location kh√¥ng h·ª£p l·ªá" });
      validLocationId = location.id;
    }

    // --- Ki·ªÉm tra departure ---
    let validDepartureId = null;
    if (departureId) {
      const departure = await Departure.findByPk(departureId);
      if (!departure)
        return res.status(400).json({ error: "Departure kh√¥ng h·ª£p l·ªá" });
      validDepartureId = departure.id;
    }

    // --- T√≠nh s·ªë ng√†y ---
    let duration = 0;
    if (startDate && endDate) {
      duration = Math.ceil(
        (new Date(endDate) - new Date(startDate)) / (1000 * 60 * 60 * 24)
      );
    }

    // --- T·∫°o tour ---
    const tour = await Tour.create(
      {
        name,
        slug: Tour.slugify(name),
        description,
        price: Number(price),
        startDate,
        endDate,
        duration,
        capacity: Number(capacity),
        image: req.file ? req.file.path : null,
        status,
        hotel_id: hotel_id ? Number(hotel_id) : null,
        fixedCategoryId,
        location_id: validLocationId,
        discount: Number(discount),
        isHotDeal: Boolean(isHotDeal),
        departureId: validDepartureId,
      },
      { transaction: t }
    );

    // --- G√°n Destination (N-N) ---
    if (Array.isArray(destinationIds) && destinationIds.length > 0) {
      const dests = await Destination.findAll({
        where: { id: destinationIds },
      });
      await tour.setDestinations(dests, { transaction: t });
      console.log("‚úÖ Destinations linked:", dests.map((d) => d.id));
    }

    // --- G√°n Optional Category (N-N) ---
    if (Array.isArray(optionalCategoryIds) && optionalCategoryIds.length > 0) {
      const optionalCats = await Category.findAll({
        where: { id: optionalCategoryIds, type: "optional" },
      });
      await tour.addOptionalCategories(optionalCats, { transaction: t });
      console.log("‚úÖ Optional categories linked:", optionalCats.map((c) => c.id));
    }

    // --- T·∫°o TourDay + TourDayDestination ---
    if (Array.isArray(daysData) && daysData.length > 0) {
      for (const day of daysData) {
        const tourDay = await TourDay.create(
          {
            tourId: tour.id,
            dayNumber: day.dayNumber,
            title: day.title,
            description: day.description,
          },
          { transaction: t }
        );

        if (Array.isArray(day.destinationIds) && day.destinationIds.length > 0) {
          for (let i = 0; i < day.destinationIds.length; i++) {
            await TourDayDestination.create(
              {
                tourDayId: tourDay.id,
                destinationId: day.destinationIds[i],
                order: i + 1,
              },
              { transaction: t }
            );
          }
        }
      }
    }

    await t.commit();

    res.status(201).json({
      success: true,
      data: { ...tour.toJSON(), salePrice: tour.salePrice },
    });
  } catch (err) {
    await t.rollback();
    console.error("‚ùå Create tour error:", err);
    res.status(500).json({ error: err.message });
  }
};

exports.updateTour = async (req, res) => {
  try {
    const { id } = req.params;
    const {
      name,
      description,
      price,
      startDate,
      endDate,
      duration,
      capacity,
      status,
      tourStatus,
      categoryId,
      locationId,
    } = req.body;

    const tour = await Tour.findByPk(id);
    if (!tour) {
      return res.status(404).json({ success: false, error: "Kh√¥ng t√¨m th·∫•y tour" });
    }

    // ‚úÖ N·∫øu c√≥ file ·∫£nh m·ªõi
    if (req.file) {
      // üßπ X√≥a ·∫£nh c≈© tr√™n Cloudinary (n·∫øu c√≥)
      if (tour.image && tour.image.includes("cloudinary.com")) {
        try {
          const publicId = tour.image.split("/").pop().split(".")[0];
          await cloudinary.uploader.destroy(`travel-booking/${publicId}`);
        } catch (error) {
          console.warn("‚ö†Ô∏è Kh√¥ng th·ªÉ xo√° ·∫£nh c≈© Cloudinary:", error.message);
        }
      }

      // ‚òÅÔ∏è Upload ·∫£nh m·ªõi l√™n Cloudinary
      const result = await cloudinary.uploader.upload(req.file.path, {
        folder: "travel-booking/tours",
      });

      // G√°n ƒë∆∞·ªùng d·∫´n m·ªõi
      tour.image = result.secure_url;

      // X√≥a file t·∫°m local sau khi upload
      fs.unlinkSync(req.file.path);
    }

    // ‚úÖ C·∫≠p nh·∫≠t c√°c tr∆∞·ªùng kh√°c
    tour.name = name || tour.name;
    tour.description = description || tour.description;
    tour.price = price || tour.price;
    tour.startDate = startDate || tour.startDate;
    tour.endDate = endDate || tour.endDate;
    tour.duration = duration || tour.duration;
    tour.capacity = capacity || tour.capacity;
    tour.categoryId = categoryId || tour.categoryId;
    tour.locationId = locationId || tour.locationId;
    tour.status = typeof status !== "undefined" ? (status === "true" || status === true) : tour.status;
    tour.tourStatus = tourStatus || tour.tourStatus;

    await tour.save();

    res.json({
      success: true,
      message: "C·∫≠p nh·∫≠t tour th√†nh c√¥ng",
      data: tour,
    });
  } catch (err) {
    console.error("‚ùå L·ªói updateTour:", err);
    res.status(500).json({ success: false, error: err.message });
  }
};
// X√≥a tour
exports.deleteTour = async (req, res) => {
  try {
    const tour = await Tour.findByPk(req.params.id);
    if (!tour) return res.status(404).json({ error: "Kh√¥ng c√≥ tour" });

    await tour.destroy();
    res.json({ message: "X√≥a tour th√†nh c√¥ng" });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
};

// L·∫•y tour theo category
exports.getToursByCategory = async (req, res) => {
  try {
    const { categoryId } = req.params;
    const category = await Category.findByPk(categoryId);
    if (!category) return res.status(404).json({ error: "Kh√¥ng c√≥ danh m·ª•c" });

    let tours;
    if (category.type === "fixed") {
      tours = await Tour.findAll({
        where: { fixedCategoryId: categoryId },
        include: [{ model: Category, as: "fixedCategory" }]
      });
    } else {
      tours = await Tour.findAll({
        include: [{
          model: Category,
          as: "optionalCategories",
          where: { id: categoryId },
          through: { attributes: [] }
        }]
      });
    }

    res.json(tours.map(tour => ({
      ...tour.toJSON(),
      salePrice: tour.salePrice
    })));
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
};

exports.getToursByFixedCategory = async (req, res) => {
  try {
    const { slug } = req.params;

    const category = await Category.findOne({
      where: { slug, type: "fixed" }
    });

    if (!category) {
      return res.status(404).json({ error: "Danh m·ª•c c·ªë ƒë·ªãnh kh√¥ng t·ªìn t·∫°i" });
    }

    const tours = await Tour.findAll({
      where: { fixedCategoryId: category.id },
      include: TOUR_INCLUDE
    });

    res.json({
      success: true,
      data: tours.map(tour => ({
        ...tour.toJSON(),
        salePrice: tour.salePrice
      }))
    });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
};

exports.getHotDeals = async (req, res) => {
  try {
    const tours = await Tour.findAll({
      where: { isHotDeal: true },
      include: TOUR_INCLUDE
    });

    res.json({
      success: true,
      data: tours.map(tour => ({
        ...tour.toJSON(),
        salePrice: tour.salePrice,       // gi√° sau gi·∫£m
        statusComputed: tour.tourStatus // tr·∫°ng th√°i t√≠nh to√°n
      }))
    });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
};

exports.searchTours = async (req, res) => {
  try {
    const { destination, date, minPrice, maxPrice } = req.query;

    let whereClause = {};

    // Filter theo date
    if (date) {
      whereClause.startDate = { [Op.gte]: new Date(date) };
    }

    // Filter theo price
    if (minPrice || maxPrice) {
      whereClause.price = {};
      if (minPrice) whereClause.price[Op.gte] = Number(minPrice);
      if (maxPrice) whereClause.price[Op.lte] = Number(maxPrice);
    }

    // Filter theo destination
    let locationFilter = {};
    if (destination) {
      const location = await Location.findOne({
        where: {
          name: { [Op.like]: `%${destination}%` }  // t√¨m g·∫ßn ƒë√∫ng
        }
      });
      if (!location) {
        // N·∫øu kh√¥ng t√¨m th·∫•y location n√†o, tr·∫£ v·ªÅ r·ªóng
        return res.json({ success: true, data: [] });
      }
      locationFilter = { location_id: location.id };
    }

    const tours = await Tour.findAll({
      where: { ...whereClause, ...locationFilter },
      include: TOUR_INCLUDE
    });

    res.json({
      success: true,
      data: tours.map(tour => ({
        ...tour.toJSON(),
        salePrice: tour.salePrice
      }))
    });

  } catch (err) {
    console.error(err);
    res.status(500).json({ error: err.message });
  }
};

exports.getToursByDestination = async (req, res) => {
  try {
    const { destinationId } = req.params;

    // Ki·ªÉm tra destination c√≥ t·ªìn t·∫°i
    const destination = await Destination.findByPk(destinationId);
    if (!destination) {
      return res.status(404).json({ error: "Destination kh√¥ng t·ªìn t·∫°i" });
    }

    // L·∫•y c√°c tour c√≥ li√™n k·∫øt v·ªõi destinationId qua b·∫£ng trung gian
    const tours = await Tour.findAll({
      include: [
        ...TOUR_INCLUDE,
        {
          model: Destination,
          as: "destinations",
          through: { attributes: [] }, // ·∫©n c·ªôt trung gian
          where: { id: destinationId }, // l·ªçc theo id
        },
      ],
    });

    res.json({
      success: true,
      data: tours.map((tour) => ({
        ...tour.toJSON(),
        salePrice: tour.salePrice,
        statusComputed: tour.tourStatus,
      })),
    });
  } catch (err) {
    console.error("getToursByDestination error:", err);
    res.status(500).json({ error: err.message });
  }
};
